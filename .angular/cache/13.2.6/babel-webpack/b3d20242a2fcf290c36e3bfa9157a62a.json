{"ast":null,"code":"import { HttpHeaders, HttpRequest } from '@angular/common/http';\nimport { GlobalService } from './global.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./authentication.service\";\nexport let ProductService = /*#__PURE__*/(() => {\n  class ProductService {\n    constructor(httpClient, authService) {\n      this.httpClient = httpClient;\n      this.authService = authService;\n    }\n\n    getProductsByCategory(uri) {\n      return this.httpClient.get(uri, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      });\n    }\n\n    getAllProducts(uri) {\n      /* la partie de traitement de lexpiration du access-token et la manip du refresh-token n'est pas fonctionnelle efficacement. Ca donne un résultat correcte,\n      // mais pas encore maturée. Cote backend c'est validé, il reste qlq optimisations cote frontend.\n      if (this.authService.isJwtExpired()) {\n        console.log(\"getAllProducts(): jwtAccessToken is expired ! \");\n        // traiter le cas de manipulation du refresh-token\n        this.authService.sendRefreshTokenAndGetNewAccessToken()\n          .subscribe(response => {\n            // manipuler la variable jwtAuthToken de authService afin de centraliser le stockage du JWT\n            this.authService.jwtAuthToken = response;\n            console.log(\"getAllProducts().sendRefreshTokenAndGetNewAccessToken().jwtAuthToken: \");\n            console.log(this.authService.jwtAuthToken);\n            this.authService.saveJwtAuthTokenToLocalStorage();\n            this.authService.parseJwtAuthTokenAndInitUsernameRoles();\n          }, err => {\n            console.log(err);\n          });\n            // throw new Error(\"JWT Access Token est expiré!\");\n      }\n      */\n      let authorizationHeader = new HttpHeaders({\n        'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n      });\n      return this.httpClient.get(uri, {\n        headers: authorizationHeader\n      });\n    }\n\n    getProducts(pageNbr, size) {\n      return this.httpClient.get(GlobalService.HOST + \"/products?page=\" + pageNbr + \"&size=\" + size, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      });\n    }\n\n    searchProductsByKeyword(keyword, pageNbr, size) {\n      return this.httpClient.get(GlobalService.HOST + \"/products/search/filterByDesignationPage?key=\" + keyword + \"&page=\" + pageNbr + \"&size=\" + size, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      });\n    }\n\n    deleteProduct(URL) {\n      // Noter bien que la mtd DELETE ne retourne rien\n      return this.httpClient.delete(URL, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      });\n    }\n\n    updateProductAssociation(UriOfCategoryOfProductToEdit, UriOfNewCategory) {\n      // this.httpClient.put(uriOfRsrcToUpdate, bodyOfRequest(or updatedData), headers)\n      // e.g: put(…/products/2/category, …/categories/3)\n      return this.httpClient.put(UriOfCategoryOfProductToEdit, UriOfNewCategory, {\n        headers: new HttpHeaders({\n          'Content-Type': 'text/uri-list',\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      });\n    }\n\n    updateProduct(URL, dataOfEditedProduct) {\n      return this.httpClient.put(URL, dataOfEditedProduct, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      });\n    }\n\n    patchProduct(URL, dataOfEditedProduct) {\n      return this.httpClient.patch(URL, dataOfEditedProduct, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      });\n    }\n\n    saveProduct(URL, data) {\n      // Noter bien que la mtd POST RETROUNE l objet enregistre format JSON, avec ses propres _links\n      return this.httpClient.post(URL, data, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      });\n    }\n\n    getProduct(URL) {\n      return this.httpClient.get(URL, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      });\n    }\n\n    getProductPhoto(URL) {\n      return this.httpClient.get(URL, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      }); //pas besoin ,{ headers: new HttpHeaders({ 'Content-Type': 'image/png' }) }\n    }\n\n    getCategoryOfProduct(URICategory) {\n      return this.httpClient.get(URICategory, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        })\n      });\n    }\n    /*\n    Envoyer la photo au backend\n    photo: la photo a uploader\n    idProductToUpdate: l'id du product dont on veut maj la photo\n    */\n    //\n\n\n    uploadProductPhoto(photo, idProductToUpdate) {\n      // on peut utiliser ce meme programme pr uploader differents types de fichiers (excel, ...)\n      // Encapsuler la photo selectionnee par l'utilisateur ds un objet FormaData. \n      // C'est cet objet qui sera serialisé au backend ds une requete POST\n      let formData = new FormData();\n      formData.append('photoFile', photo); // construire une requete POST\n      // Comme constaté, uploader un fichier vers le backend, \n      // consiste à envoyer une requete POST contenant le fichier à envoyer ds son body.\n\n      const req = new HttpRequest('POST', GlobalService.HOST + '/upload-product-photo/' + idProductToUpdate, formData, {\n        headers: new HttpHeaders({\n          'Authorization': \"Bearer \" + this.authService.getJwtAccessToken()\n        }),\n        // pr recevoir la progression d'ulpoad\n        reportProgress: true,\n        // on veut recevoir une reponse Text, non pas JSON.\n        responseType: 'text'\n      });\n      return this.httpClient.request(req);\n    }\n\n  }\n\n  ProductService.ɵfac = function ProductService_Factory(t) {\n    return new (t || ProductService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.AuthenticationService));\n  };\n\n  ProductService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ProductService,\n    factory: ProductService.ɵfac,\n    providedIn: 'root'\n  });\n  return ProductService;\n})();","map":null,"metadata":{},"sourceType":"module"}